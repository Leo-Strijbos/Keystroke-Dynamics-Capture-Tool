{"ast":null,"code":"var readFile = require('fs').readFile,\n    basename = require('path').basename;\n\nexports.build = function (data, boundary, callback) {\n  if (typeof data != 'object' || typeof data.pipe == 'function') return callback(new Error('Multipart builder expects data as key/val object.'));\n  var body = '',\n      object = flatten(data),\n      count = Object.keys(object).length;\n  if (count === 0) return callback(new Error('Empty multipart body. Invalid data.'));\n\n  function done(err, section) {\n    if (err) return callback(err);\n    if (section) body += section;\n    --count || callback(null, body + '--' + boundary + '--');\n  }\n\n  ;\n\n  for (var key in object) {\n    var value = object[key];\n\n    if (value === null || typeof value == 'undefined') {\n      done();\n    } else if (Buffer.isBuffer(value)) {\n      var part = {\n        buffer: value,\n        content_type: 'application/octet-stream'\n      };\n      generate_part(key, part, boundary, done);\n    } else {\n      var part = value.buffer || value.file || value.content_type ? value : {\n        value: value\n      };\n      generate_part(key, part, boundary, done);\n    }\n  }\n};\n\nfunction generate_part(name, part, boundary, callback) {\n  var return_part = '--' + boundary + '\\r\\n';\n  return_part += 'Content-Disposition: form-data; name=\"' + name + '\"';\n\n  function append(data, filename) {\n    if (data) {\n      var binary = part.content_type.indexOf('text') == -1;\n      return_part += '; filename=\"' + encodeURIComponent(filename) + '\"\\r\\n';\n      if (binary) return_part += 'Content-Transfer-Encoding: binary\\r\\n';\n      return_part += 'Content-Type: ' + part.content_type + '\\r\\n\\r\\n';\n      return_part += binary ? data.toString('binary') : data.toString('utf8');\n    }\n\n    callback(null, return_part + '\\r\\n');\n  }\n\n  ;\n\n  if ((part.file || part.buffer) && part.content_type) {\n    var filename = part.filename ? part.filename : part.file ? basename(part.file) : name;\n    if (part.buffer) return append(part.buffer, filename);\n    readFile(part.file, function (err, data) {\n      if (err) return callback(err);\n      append(data, filename);\n    });\n  } else {\n    if (typeof part.value == 'object') return callback(new Error('Object received for ' + name + ', expected string.'));\n\n    if (part.content_type) {\n      return_part += '\\r\\n';\n      return_part += 'Content-Type: ' + part.content_type;\n    }\n\n    return_part += '\\r\\n\\r\\n';\n    return_part += Buffer.from(String(part.value), 'utf8').toString('binary');\n    append();\n  }\n} // flattens nested objects for multipart body\n\n\nfunction flatten(object, into, prefix) {\n  into = into || {};\n\n  for (var key in object) {\n    var prefix_key = prefix ? prefix + '[' + key + ']' : key;\n    var prop = object[key];\n    if (prop && typeof prop === 'object' && !(prop.buffer || prop.file || prop.content_type)) flatten(prop, into, prefix_key);else into[prefix_key] = prop;\n  }\n\n  return into;\n}","map":{"version":3,"sources":["/Users/leostrijbos/Desktop/Development/Websites/find_kanye copy/node_modules/needle/lib/multipart.js"],"names":["readFile","require","basename","exports","build","data","boundary","callback","pipe","Error","body","object","flatten","count","Object","keys","length","done","err","section","key","value","Buffer","isBuffer","part","buffer","content_type","generate_part","file","name","return_part","append","filename","binary","indexOf","encodeURIComponent","toString","from","String","into","prefix","prefix_key","prop"],"mappings":"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","sourcesContent":["var readFile = require('fs').readFile,\n    basename = require('path').basename;\n\nexports.build = function(data, boundary, callback) {\n\n  if (typeof data != 'object' || typeof data.pipe == 'function')\n    return callback(new Error('Multipart builder expects data as key/val object.'));\n\n  var body   = '',\n      object = flatten(data),\n      count  = Object.keys(object).length;\n\n  if (count === 0)\n    return callback(new Error('Empty multipart body. Invalid data.'))\n\n  function done(err, section) {\n    if (err) return callback(err);\n    if (section) body += section;\n    --count || callback(null, body + '--' + boundary + '--');\n  };\n\n  for (var key in object) {\n    var value = object[key];\n    if (value === null || typeof value == 'undefined') {\n      done();\n    } else if (Buffer.isBuffer(value)) {\n      var part = { buffer: value, content_type: 'application/octet-stream' };\n      generate_part(key, part, boundary, done);\n    } else {\n      var part = (value.buffer || value.file || value.content_type) ? value : { value: value };\n      generate_part(key, part, boundary, done);\n    }\n  }\n\n}\n\nfunction generate_part(name, part, boundary, callback) {\n\n  var return_part = '--' + boundary + '\\r\\n';\n  return_part += 'Content-Disposition: form-data; name=\"' + name + '\"';\n\n  function append(data, filename) {\n\n    if (data) {\n      var binary = part.content_type.indexOf('text') == -1;\n      return_part += '; filename=\"' + encodeURIComponent(filename) + '\"\\r\\n';\n      if (binary) return_part += 'Content-Transfer-Encoding: binary\\r\\n';\n      return_part += 'Content-Type: ' + part.content_type + '\\r\\n\\r\\n';\n      return_part += binary ? data.toString('binary') : data.toString('utf8');\n    }\n\n    callback(null, return_part + '\\r\\n');\n  };\n\n  if ((part.file || part.buffer) && part.content_type) {\n\n    var filename = part.filename ? part.filename : part.file ? basename(part.file) : name;\n    if (part.buffer) return append(part.buffer, filename);\n\n    readFile(part.file, function(err, data) {\n      if (err) return callback(err);\n      append(data, filename);\n    });\n\n  } else {\n\n    if (typeof part.value == 'object')\n      return callback(new Error('Object received for ' + name + ', expected string.'))\n\n    if (part.content_type) {\n      return_part += '\\r\\n';\n      return_part += 'Content-Type: ' + part.content_type;\n    }\n\n    return_part += '\\r\\n\\r\\n';\n    return_part += Buffer.from(String(part.value), 'utf8').toString('binary');\n    append();\n\n  }\n\n}\n\n// flattens nested objects for multipart body\nfunction flatten(object, into, prefix) {\n  into = into || {};\n\n  for(var key in object) {\n    var prefix_key = prefix ? prefix + '[' + key + ']' : key;\n    var prop = object[key];\n\n    if (prop && typeof prop === 'object' && !(prop.buffer || prop.file || prop.content_type))\n      flatten(prop, into, prefix_key)\n    else\n      into[prefix_key] = prop;\n  }\n\n  return into;\n}\n"]},"metadata":{},"sourceType":"script"}